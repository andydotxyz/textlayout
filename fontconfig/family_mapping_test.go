package fontconfig

import (
	"fmt"
	"os"
	"sort"
	"strings"
	"testing"
)

func (d directive) isFamilyAlias() (family string) {
	if len(d.tests) != 1 {
		return ""
	}
	test := d.tests[0]
	if test.object == FAMILY && test.op.getOp() == opEqual {
		if s, ok := test.expr.u.(String); ok && test.expr.op == opString {
			return string(s)
		}
	}
	return ""
}

func exprAsStringList(expr *expression) []string {
	if s, ok := expr.u.(String); ok && expr.op == opString {
		return []string{string(s)}
	}

	if c, ok := expr.u.(exprTree); ok && expr.op == opComma {
		l1 := exprAsStringList(c.left)
		l2 := exprAsStringList(c.right)
		return append(l1, l2...)
	}

	return nil
}

func printSubstitutions(m map[string][]string, outfile string) {
	f, err := os.Create(outfile)
	if err != nil {
		panic(err)
	}

	fmt.Fprintln(f, `package fontconfig

// Code generated by ... DO NOT EDIT.

var familySubstitution = map[string][]string{`)

	var keys []string
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		v := m[k]
		var c []string
		for _, s := range v {
			c = append(c, fmt.Sprintf("%q", s))
		}
		fmt.Fprintf(f, "\t%q: {%s},\n", k, strings.Join(c, ", "))
	}

	fmt.Fprintln(f, "}")

	f.Close()
}

func TestMap(t *testing.T) {
	subs := map[string][]string{}

	for _, ruleset := range Standard.subst {
		// comment := fmt.Sprintf("%s (%s)", ruleset.name, ruleset.description)

		for _, directive := range ruleset.subst[MatchQuery] {
			if family := directive.isFamilyAlias(); family != "" {
				for _, edit := range directive.edits {
					if edit.object == FAMILY {
						l := exprAsStringList(edit.expr)
						currentL := subs[family]
						if len(currentL) == 0 {
							// include the original, unless
							// for Assign
							currentL = []string{family}
						}
						switch edit.op.getOp() {
						case opAppend, opAppendLast:
							currentL = append(currentL, l...)
						case opPrepend:
							currentL = append(l, currentL...)
						case opAssign:
							currentL = l
						default:
							t.Errorf("unexpected operation %v", edit.op)
						}
						subs[family] = currentL
					}
				}
			}
		}
	}

	// printSubstitutions(subs, "families.go")
}
