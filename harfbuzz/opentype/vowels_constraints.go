package opentype

import (
	"github.com/benoitkugler/textlayout/harfbuzz/common"
	"github.com/benoitkugler/textlayout/language"
)

// Code generated by unicodedata/generate/main.go DO NOT EDIT.

func outputDottedCircle(buffer *common.Buffer) {
	dottedcircle := buffer.OutputGlyph(0x25CC)
	dottedcircle.ResetContinutation()
}

func outputWithDottedCircle(buffer *common.Buffer) {
	outputDottedCircle(buffer)
	buffer.NextGlyph()
}

func preprocessTextVowelConstraints(buffer *common.Buffer) {
	if (buffer.Flags & common.HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE) != 0 {
		return
	}

	/* UGLY UGLY UGLY business of adding dotted-circle in the middle of
	* vowel-sequences that look like another vowel. Data for each script
	* collected from the USE script development spec.
	*
	* https://github.com/harfbuzz/harfbuzz/issues/1019
	 */
	processed := false
	buffer.ClearOutput()
	count := len(buffer.Info)
	switch buffer.Props.Script {

	case language.Devanagari:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0905:
				switch buffer.Cur(1).Codepoint {
				case 0x093A:
					matched = true
				case 0x093B:
					matched = true
				case 0x0945:
					matched = true
				case 0x0946:

					matched = true
				case 0x094A:
					matched = true
				case 0x094B:
					matched = true
				case 0x094C:
					matched = true
				case 0x094F:

					matched = true
				case 0x0956:
					matched = true
				case 0x0957:
					matched = true
				}
			case 0x0906:
				switch buffer.Cur(1).Codepoint {
				case 0x093A:
					matched = true
				case 0x0945:
					matched = true
				case 0x0947:
					matched = true
				case 0x0948:
					matched = true
				}
			case 0x0909:
				matched = 0x0941 == buffer.Cur(1).Codepoint
			case 0x090F:
				switch buffer.Cur(1).Codepoint {
				case 0x0945:
					matched = true
				case 0x0947:
					matched = true
				}
			case 0x0930:
				if 0x094D == buffer.Cur(1).Codepoint &&
					buffer.Idx+2 < count &&
					0x0907 == buffer.Cur(2).Codepoint {
					buffer.NextGlyph()
					matched = true
				}
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Bengali:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0985:
				matched = 0x09BE == buffer.Cur(1).Codepoint
			case 0x098C:
				matched = 0x09E2 == buffer.Cur(1).Codepoint
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Gurmukhi:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0A05:
				switch buffer.Cur(1).Codepoint {
				case 0x0A3E:
					matched = true
				case 0x0A4C:
					matched = true
				}
			case 0x0A72:
				switch buffer.Cur(1).Codepoint {
				case 0x0A40:
					matched = true
				}
			case 0x0A73:
				switch buffer.Cur(1).Codepoint {
				case 0x0A41:
					matched = true
				case 0x0A4B:
					matched = true
				}
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Gujarati:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0A85:
				switch buffer.Cur(1).Codepoint {
				case 0x0ABE:
					matched = true
				case 0x0AC8:
					matched = true
				case 0x0AC9:
					matched = true
				case 0x0ACB:

					matched = true
				case 0x0ACC:
					matched = true
				}
			case 0x0AC5:
				matched = 0x0ABE == buffer.Cur(1).Codepoint
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Oriya:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0B05:
				matched = 0x0B3E == buffer.Cur(1).Codepoint
			case 0x0B13:
				matched = 0x0B57 == buffer.Cur(1).Codepoint
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Tamil:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			if 0x0B85 == buffer.Cur(0).Codepoint &&
				0x0BC2 == buffer.Cur(1).Codepoint {
				matched = true
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Telugu:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0C12:
				matched = 0x0C55 == buffer.Cur(1).Codepoint
			case 0x0C3F:
				matched = 0x0C55 == buffer.Cur(1).Codepoint
			case 0x0C46:
				matched = 0x0C55 == buffer.Cur(1).Codepoint
			case 0x0C4A:
				matched = 0x0C55 == buffer.Cur(1).Codepoint
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Kannada:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0C89:
				matched = 0x0CBE == buffer.Cur(1).Codepoint
			case 0x0C8B:
				matched = 0x0CBE == buffer.Cur(1).Codepoint
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Malayalam:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0D07:
				matched = 0x0D57 == buffer.Cur(1).Codepoint
			case 0x0D0E:
				matched = 0x0D46 == buffer.Cur(1).Codepoint
			case 0x0D12:
				switch buffer.Cur(1).Codepoint {
				case 0x0D3E:
					matched = true
				}
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Sinhala:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x0D85:
				switch buffer.Cur(1).Codepoint {
				case 0x0DCF:
					matched = true
				}
			case 0x0D8B:
				matched = 0x0DDF == buffer.Cur(1).Codepoint
			case 0x0D8F:
				matched = 0x0DDF == buffer.Cur(1).Codepoint
			case 0x0D94:
				matched = 0x0DDF == buffer.Cur(1).Codepoint
			case 0x0D8D:
				matched = 0x0DD8 == buffer.Cur(1).Codepoint
			case 0x0D91:
				switch buffer.Cur(1).Codepoint {
				case 0x0DCA:
					matched = true
				case 0x0DDA:
					matched = true
				case 0x0DDC:
					matched = true
				case 0x0DDD:

					matched = true
				case 0x0DDE:
					matched = true
				}
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Brahmi:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x11005:
				matched = 0x11038 == buffer.Cur(1).Codepoint
			case 0x1100F:
				matched = 0x11042 == buffer.Cur(1).Codepoint
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Khudawadi:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x112B0:
				switch buffer.Cur(1).Codepoint {
				case 0x112E0:
					matched = true
				case 0x112E7:
					matched = true
				case 0x112E8:
					matched = true
				}
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Tirhuta:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x11481:
				matched = 0x114B0 == buffer.Cur(1).Codepoint
			case 0x1148B:
				matched = 0x114BA == buffer.Cur(1).Codepoint
			case 0x1148D:
				matched = 0x114BA == buffer.Cur(1).Codepoint
			case 0x114AA:
				matched = 0x114B6 == buffer.Cur(1).Codepoint
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Modi:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x11600:
				matched = 0x11639 == buffer.Cur(1).Codepoint
			case 0x11601:
				switch buffer.Cur(1).Codepoint {
				case 0x11639:
					matched = true
				}
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	case language.Takri:
		for buffer.Idx = 0; buffer.Idx+1 < count; {
			matched := false
			switch buffer.Cur(0).Codepoint {
			case 0x11680:
				switch buffer.Cur(1).Codepoint {
				case 0x116AD:
					matched = true
				case 0x116B5:
					matched = true
				}
			}

			buffer.NextGlyph()
			if matched {
				outputWithDottedCircle(buffer)
			}
		}
		processed = true
	}
	if processed {
		if buffer.Idx < count {
			buffer.NextGlyph()
		}
		buffer.SwapBuffers()
	}
}
