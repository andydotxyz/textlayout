package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"sort"
	"unicode"

	"golang.org/x/text/unicode/rangetable"
)

const header = `
package unicodedata

// Code generated by generate/main.go DO NOT EDIT.

`

// compacts the code more than a "%#v" directive
func printTable(rt *unicode.RangeTable, omitTypeLitteral bool) string {
	w := new(bytes.Buffer)
	if omitTypeLitteral {
		fmt.Fprintln(w, "{")
	} else {
		fmt.Fprintln(w, "&unicode.RangeTable{")
	}
	if len(rt.R16) > 0 {
		fmt.Fprintln(w, "\tR16: []unicode.Range16{")
		for _, r := range rt.R16 {
			fmt.Fprintf(w, "\t\t{Lo:%#04x, Hi:%#04x, Stride:%d},\n", r.Lo, r.Hi, r.Stride)
		}
		fmt.Fprintln(w, "\t},")
	}
	if len(rt.R32) > 0 {
		fmt.Fprintln(w, "\tR32: []unicode.Range32{")
		for _, r := range rt.R32 {
			fmt.Fprintf(w, "\t\t{Lo:%#x, Hi:%#x,Stride:%d},\n", r.Lo, r.Hi, r.Stride)
		}
		fmt.Fprintln(w, "\t},")
	}
	if rt.LatinOffset > 0 {
		fmt.Fprintf(w, "\tLatinOffset: %d,\n", rt.LatinOffset)
	}
	fmt.Fprintf(w, "}")
	return w.String()
}

func generateCombiningClasses(classes map[uint8][]rune, w io.Writer) {
	fmt.Fprintln(w, header)

	// create and compact the tables
	var out [256]*unicode.RangeTable
	for k, v := range classes {
		if len(v) == 0 {
			return
		}
		out[k] = rangetable.New(v...)
	}

	// print them
	fmt.Fprintln(w, "var combiningClasses = [256]*unicode.RangeTable{")
	for i, t := range out {
		if t == nil {
			continue
		}
		fmt.Fprintf(w, "%d : %s,\n", i, printTable(t, true))
	}
	fmt.Fprintln(w, "}")
}

func generateEmojis(runes map[string][]rune, w io.Writer) {
	fmt.Fprintln(w, header)
	var classes = [...]string{"Emoji", "Emoji_Presentation", "Emoji_Modifier", "Emoji_Modifier_Base", "Extended_Pictographic"}
	for _, class := range classes {
		table := rangetable.New(runes[class]...)
		s := printTable(table, false)
		fmt.Fprintf(w, "var %s = %s\n\n", class, s)
	}

}
func generateMirroring(runes map[uint16]uint16, w io.Writer) {
	fmt.Fprintln(w, header)
	fmt.Fprintln(w, "var mirroring = map[rune]rune{")
	var sorted []int
	for r1 := range runes {
		sorted = append(sorted, int(r1))
	}
	sort.Ints(sorted)
	for _, r1 := range sorted {
		r2 := runes[uint16(r1)]
		fmt.Fprintf(w, "0x%04x: 0x%04x,\n", r1, r2)
	}
	fmt.Fprintln(w, "}")
}

func generateDecomposition(dms map[rune][]rune, compExp map[rune]bool, w io.Writer) {
	var (
		decompose1 = map[rune]rune{}    // length 1 mappings
		decompose2 = map[rune][2]rune{} // length 2 mappings
		compose    = map[[2]rune]rune{} // length 2 mappings
		ccc        = map[rune]bool{}    // has combining class
	)
	for c, runes := range combiningClasses {
		for _, r := range runes {
			ccc[r] = c != 0
		}
	}
	for r, v := range dms {
		switch len(v) {
		case 1:
			decompose1[r] = v[0]
		case 2:
			decompose2[r] = [2]rune{v[0], v[1]}
			var composed rune
			if !compExp[r] && !ccc[r] {
				composed = r
			}
			compose[[2]rune{v[0], v[1]}] = composed
		default:
			log.Fatalf("unexpected runes for decomposition: %d, %v", r, v)
		}
	}

	fmt.Fprintln(w, header)

	fmt.Fprintln(w, "var decompose1 = map[rune]rune{")
	for k, v := range decompose1 {
		fmt.Fprintf(w, "0x%04x: 0x%04x,\n", k, v)
	}
	fmt.Fprintln(w, "}")

	fmt.Fprintln(w, "var decompose2 = map[rune][2]rune{")
	for k, v := range decompose2 {
		fmt.Fprintf(w, "0x%04x: {0x%04x,0x%04x},\n", k, v[0], v[1])
	}
	fmt.Fprintln(w, "}")

	fmt.Fprintln(w, "var compose = map[[2]rune]rune{")
	for k, v := range compose {
		fmt.Fprintf(w, "{0x%04x,0x%04x}: 0x%04x,\n", k[0], k[1], v)
	}
	fmt.Fprintln(w, "}")
}
